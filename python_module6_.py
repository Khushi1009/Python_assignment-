# -*- coding: utf-8 -*-
"""Python_Module6 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jRlJICJdLnICpAllkCimDa_20kExjMbN
"""



"""1.What are the five key concepts of Object-Oriented Programming (OOP)?

Ans.

**Inheritance**


1.   Inheritance allows a class (child or derived) to acquire the properties and methods of another class (parent or base), enabling reusability and the creation of hierarchical relationships.
2.   To promote code reuse and establish a natural hierarchy.

3.   Example: A Vehicle class could be a parent class, with Car and Truck as derived classes inheriting its attributes and methods.

**Abstraction**

1.   Abstraction focuses on hiding the complexity of a system and exposing only the essential features relevant to the user.
2.   To reduce programming complexity and effort by providing a clear interface and hiding implementation details.

3.   Example: A car class exposes methods like start() or drive() without revealing the underlying mechanics of the engine.

**Polymorphism**


1.   Polymorphism enables objects to be treated as instances of their parent class while allowing for method overriding to define specific behaviors.
2.  To allow one interface to be used for different types or classes.

3.   Example: A method draw() might be defined in a Shape class, with specific implementations in Circle and Square.

**Encapsulation**


1.    Encapsulation is the bundling of data (attributes) and methods (functions) that operate on the data into a single unit, known as a class. It also restricts direct access to some components to maintain integrity.
2.  To hide the internal state and require all interactions to occur through defined interfaces.


**Class/Object**
1.    A class is a blueprint or template that defines the properties (attributes) and behaviors (methods) of an object, while an object is an instance of a class.

2.   Classes provide structure and definition, and objects represent specific, usable entities created from those classes.
3.   Example: A Person class may have attributes like name and age and methods like speak(). An instance, or object, of this class would be a specific person, e.g., john = Person("John", 30).






















"""

#2. Write a Python class for a `Car` with attributes for `make`, `model`, and `year`. Include a method to display the car's information

class Car:
    def __init__(self, make, model, year):

        #Initialize the Car object with make, model, and year attributes.

        self.make = make
        self.model = model
        self.year = year

    def display_info(self):

        # Display the car's information.

       return str(self.year) + " " + self.make + " " + self.model

car = Car("Honda", "Civic", 2023)
car.display_info()

"""3. Explain the difference between instance methods and class methods. Provide an example of each.

Ans.

Instance Methods:

1.   Operate on an instance of the class.
2.   The first parameter is self, which represents the instance of the class.
3.   Can access and modify instance attributes and call other instance methods.
4.   Can only be called on an instance of the class.

Class Methods:


1.  Operate on the class itself, not a specific instance.
2.  The first parameter is cls, which represents the class.
3.  Can access and modify class-level attributes, but cannot access instance attributes directly.
4.  Decorated with @classmethod.
"""

#example of insrance method and class method

class Car:
    total_cars = 0  # to keep track of total cars created

    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        Car.total_cars += 1

    def display_details(self):
        """
        Instance method to display the car's details.
        """
        print(f"Car: {self.year} {self.make} {self.model}")

    @classmethod
    def display_total_cars(cls):
        """
        Class method to display the total number of cars created.
        """
        print(f"Total cars created: {cls.total_cars}")

car1 = Car("Toyota", "Corolla", 2020)
car2 = Car("Honda", "Civic", 2022)

# Using instance method
car1.display_details()
car2.display_details()

# Using class method
Car.display_total_cars()

#4. How does Python implement method overloading? Give an example.
"""Python does not support method overloading in the traditional sense as seen in languages like Java or C++,
 where you can define multiple methods with the same name but different parameter lists."""

class Calculator:
    def add(self, a, b=0, c=0):
        """
        Adds two or three numbers.
        """
        return a + b + c

calc = Calculator()
print(calc.add(5))
print(calc.add(5, 10))
print(calc.add(5, 10, 15))

"""5. What are the three types of access modifiers in Python? How are they denoted?

Ans.

**Public Access Modifier**

Public members in Python are those that are accessible from anywhere, both inside and outside the class. They are the default visibility for attributes and methods, meaning if no specific modifier is applied, the member is considered public. Public members can be freely accessed, modified, or called by any code that has access to the object. This makes them ideal for functionalities that should be openly available.

**Protected Access Modifier**

Protected members are intended to be accessed only within the class and its subclasses. They are not strictly enforced by Python, but a convention is followed by prefixing the member name with a single underscore (_). This serves as a hint to developers that the member is for internal use and should not be accessed directly from outside the class or its subclasses.

 **Private Access Modifier**

 Private members are designed to be completely hidden from outside the class where they are defined. They are declared by prefixing the member name with a double underscore (__). Private members are not accessible directly from outside the class or even by subclasses. Python enforces this by a mechanism called name mangling, where the member name is internally changed to include the class name as a prefix.

6. Describe the five types of inheritance in Python. Provide a simple example of multiple inheritance.

Ans.

**1. Single Inheritance**

Single inheritance involves a child class inheriting from one parent class. This type of inheritance allows the child class to reuse the methods and attributes of the parent class. It is the simplest form of inheritance and is typically used when there is a straightforward relationship between two classes. For example, a Child class could inherit from a Parent class to extend or specialize its behavior. This promotes code reuse and reduces redundancy by centralizing common features in the parent class.

**2. Multiple Inheritance**

Multiple inheritance allows a child class to inherit from more than one parent class. This is useful when the child class needs to combine features or behaviors from multiple unrelated classes. However, it can introduce complexity, especially when methods with the same name exist in multiple parent classes. Python resolves such conflicts using the Method Resolution Order (MRO), which determines the sequence in which parent classes are searched for attributes or methods. For instance, a Child class might inherit from Parent1 and Parent2, gaining access to both sets of features.


**3. Multilevel Inheritance**

Multilevel inheritance creates a chain of inheritance where a child class inherits from a parent class, which itself inherits from another parent class. This type of inheritance models a hierarchical relationship where properties and methods are passed down the inheritance chain. It is useful for representing relationships with more than two levels. For example, a Grandchild class can inherit from a Parent class, which in turn inherits from a Grandparent class, allowing the Grandchild to access features from all levels.

**4. Hierarchical Inheritance**

In hierarchical inheritance, multiple child classes inherit from a single parent class. This is useful when different classes need to share common features or behaviors defined in the parent class. Each child class can also define its own unique attributes and methods in addition to those inherited. For instance, a Parent class might define general behavior, while Child1 and Child2 extend it in their specific ways. This promotes code reuse while allowing specialization.


**5. Hybrid Inheritance**

Hybrid inheritance is a combination of two or more types of inheritance, such as multiple and hierarchical inheritance. It is used to model more complex relationships between classes. For example, a class might inherit from two parent classes (multiple inheritance) while also being part of a hierarchy. This type of inheritance is powerful but can lead to complications, such as ambiguity in method resolution, which is handled in Python through the MRO. Hybrid inheritance offers flexibility for designing intricate relationships between classes in a program.
"""

#Multiple inheritance example


class Engine:
    def start(self):
        print("Engine started.")

    def stop(self):
        print("Engine stopped.")

class Body:
    def open_doors(self):
        print("Doors opened.")

    def close_doors(self):
        print("Doors closed.")

class Car(Engine, Body):
    def drive(self):
        print("Car is driving.")


my_car = Car()

# Accessing methods from both parent classes
my_car.start()
my_car.open_doors()
my_car.drive()
my_car.close_doors()
my_car.stop()

"""7. What is the Method Resolution Order (MRO) in Python? How can you retrieve it programmatically?

Ans.

The Method Resolution Order (MRO) in Python determines the sequence in which classes are searched when executing a method or looking for an attribute. It is especially important in the context of inheritance, particularly multiple inheritance, as it defines the order in which parent classes are considered to resolve a method call.

Python uses the C3 linearization algorithm (also called C3 superclass linearization) to compute the MRO. This ensures that:

1.    Child Precedes Parent: A class always appears before its parent classes in the MRO (Method Resolution Order).
2.   Order Preservation: The order of the base classes specified during inheritance is preserved in the MRO.





"""

#MRO
class A:
    def show(self):
        print("Class A")

class B(A):
    def show(self):
        print("Class B")

class C(A):
    def show(self):
        print("Class C")

class D(B, C):
    pass

# Checking the MRO
print(D.mro())
print(D.__mro__)

# Using MRO in method calls
obj = D()
obj.show()  # Resolves to Class B

#8.Create an abstract base class `Shape` with an abstract method `area()`. Then create two subclasses `Circle` and `Rectangle` that implement the `area()` method.
from abc import ABC, abstractmethod
import math

# Abstract Base Class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass  # Abstract method that must be overridden

# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2  # Area of a circle: πr^2

# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height  # Area of rectangle: width × height

# Usage
circle = Circle(5)
print(f"Circle area: {circle.area()}")

rectangle = Rectangle(4, 6)
print(f"Rectangle area: {rectangle.area()}")

"""
9. Demonstrate polymorphism by creating a function that can work with different shape objects to calculate and print their areas.

Ans.
Polymorphism in Python allows objects of different classes to be treated as objects of a common base class.
The key idea is that a function or method can operate on objects of different types and provide the correct behavior based on the object type.
In this case, we can create a function that calculates and prints the area of any shape object
(such as Circle, Rectangle, etc.), using polymorphism.
Since all shapes have the area() method (either directly or through inheritance), the function can work with any object that implements this method.
"""
from abc import ABC, abstractmethod
import math

# Abstract Base Class
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Subclass Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2  # Area of a circle: πr^2

# Subclass Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height  # Area of rectangle: width × height

# Function that works with different shape objects
def print_area(shape: Shape):
    print(f"The area of the shape is: {shape.area()}")

circle = Circle(5)
rectangle = Rectangle(4, 6)

# Calling the function with different shape objects
print_area(circle)
print_area(rectangle)

"""
10. Implement encapsulation in a `BankAccount` class with private attributes for `balance` and `account_number`.
Include methods for deposit, withdrawal, and balance inquiry.

Ans.
Encapsulation in Python is the concept of restricting access to some of an object's attributes and methods.
This can be done by declaring attributes as private (using a double underscore prefix __) and
 providing getter and setter methods to access and modify them in a controlled manner.
In the case of a BankAccount class, we can make the balance and account_number private,
and then provide methods for deposit, withdrawal, and balance inquiry.


"""

class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        self.__account_number = account_number  # Private attribute
        self.__balance = initial_balance        # Private attribute

    # Getter method for balance
    def get_balance(self):
        return self.__balance

    # Deposit method to add money to the account
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount}. Current balance: ${self.__balance}.")
        else:
            print("Deposit amount must be positive.")

    # Withdrawal method to remove money from the account
    def withdraw(self, amount):
        if amount > 0:
            if amount <= self.__balance:
                self.__balance -= amount
                print(f"Withdrew: ${amount}. Current balance: ${self.__balance}.")
            else:
                print("Insufficient funds.")
        else:
            print("Withdrawal amount must be positive.")

    # Method to check account details (account number and balance)
    def account_info(self):
        print(f"Account Number: {self.__account_number}\nBalance: ${self.__balance}")

account = BankAccount("12345678", 1000)


account.deposit(500)

account.withdraw(300)

account.account_info()

'''
11. Write a class that overrides the `__str__` and `__add__` magic methods. What will these methods allow you to do?

Ans.
In Python, magic methods (also called dunder methods) allow you to define special behavior for objects.
Two commonly used magic methods are __str__ and __add__.

__str__: This magic method is called when you attempt to convert an object into a string (e.g., using print() or str()).
         Overriding it allows you to control the string representation of your class instances.
__add__: This magic method is called when you use the + operator between two objects of a class.
         Overriding it allows you to define how two objects of your class should be added together,
         such as adding their attributes or combining them in a specific way.
'''
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Override the __str__ method to provide a string representation of the object
    def __str__(self):
        return f"Point({self.x}, {self.y})"

    # Override the __add__ method to define how two Point objects should be added
    def __add__(self, other):
        if isinstance(other, Point):
            return Point(self.x + other.x, self.y + other.y)
        return NotImplemented  # In case of trying to add a non-Point object

# Usage Example
point1 = Point(2, 3)
point2 = Point(4, 5)

# Printing the objects (calls the __str__ method)
print(point1)
print(point2)

# Adding two Point objects (calls the __add__ method)
point3 = point1 + point2
print(point3)

"""
12. Create a decorator that measures and prints the execution time of a function.

Ans.

"""
import time

# Decorator to measure execution time
def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Record the start time
        result = func(*args, **kwargs)  # Call the original function
        end_time = time.time()  # Record the end time
        execution_time = end_time - start_time  # Calculate the execution time
        print(f"Execution time of {func.__name__}: {execution_time:.4f} seconds")
        return result  # Return the result of the function
    return wrapper

# Applying the decorator to a function
@measure_time
def slow_function():
    time.sleep(2)
    print("Function completed!")

slow_function()

"""13. Explain the concept of the Diamond Problem in multiple inheritance. How does Python resolve it?

Ans.

The Diamond Problem is a complication that arises in object-oriented programming when a class inherits from two classes that both inherit from a common ancestor class. This can cause ambiguity in the inheritance hierarchy, particularly when methods or attributes are inherited from the common ancestor. The issue occurs because it's unclear which path should be followed to access the inherited method or attribute from the common ancestor.

       A
      / \
     B   C
      \ /
       D

In this diagram:

Class A is the base class.
Classes B and C both inherit from class A.
Class D inherits from both B and C.

The Diamond Problem occurs when class D inherits attributes or methods from both B and C, and both B and C have modified or overridden the methods they inherited from class A. Python needs to determine which version of the method or attribute D should inherit.

Python's Solution:

Python uses the Method Resolution Order (MRO) to determine the order in which base classes are considered when searching for a method or attribute. The MRO specifies the order in which base classes are inherited, and it is determined using the C3 Linearization Algorithm.
"""

'''
14. Write a class method that keeps track of the number of instances created from a class.

Ans.


'''
class MyClass:
    # Class variable to track the number of instances
    instance_count = 0

    def __init__(self):
        # Increment the instance count whenever a new instance is created
        MyClass.increment_instance_count()

    @classmethod
    def increment_instance_count(cls):
        # Increment the class variable instance_count
        cls.instance_count += 1

    @classmethod
    def get_instance_count(cls):
        # Return the current number of instances created
        return cls.instance_count

# Create instances of MyClass
obj1 = MyClass()
obj2 = MyClass()
obj3 = MyClass()

print(f"Number of instances created: {MyClass.get_instance_count()}")

'''
15. Implement a static method in a class that checks if a given year is a leap year.

Ans.
'''

class YearUtils:

    @staticmethod
    def is_leap_year(year):
        # Check if the year is divisible by 4, and if divisible by 100, also by 400
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        return False

year = 2024
if YearUtils.is_leap_year(year):
    print(f"{year} is a leap year.")
else:
    print(f"{year} is not a leap year.")

# Check another year
year = 1900
if YearUtils.is_leap_year(year):
    print(f"{year} is a leap year.")
else:
    print(f"{year} is not a leap year.")